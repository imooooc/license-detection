# -*- coding:utf-8 -*-# Author: Zhu Chen # Organization: 07 LP detection group# Create Time: 2020/04  All rights reservedfrom rest_framework import serializersfrom .models import Userfrom django.contrib.auth.hashers import make_password, check_passwordclass UserSerializer(serializers.ModelSerializer):    '''    用户列表    '''    class Meta:        model = User        fields = '__all__'class RegistForm(serializers.Serializer):    '''    用户注册    '''    username = serializers.CharField(required=True, max_length=20)    email = serializers.EmailField(required=True, max_length=50)    password = serializers.CharField(required=True, max_length=256)    re_password = serializers.CharField(required=True, max_length=256)    # data = {'username':'张三', 'email':'1@1.com', 'password':'123', 're_password':'123'}    def validate(self, attrs):        if attrs['password'] != attrs['re_password']:            raise serializers.ValidationError('两次密码输入不一致')        return attrs    def save(self):        data = {}        username = self.validated_data['username']        email = self.validated_data['email']        _password = self.validated_data['password']        # sha1非对称加密保存密码        password = make_password(_password, 'vmoli', 'pbkdf2_sha1')        print('data:', data)        return User.objects.create(username=username, email=email, password=password)class ModifyPasswordForm(serializers.Serializer):    '''    验证密码    '''    username = serializers.CharField(required=True, max_length=20)    password = serializers.CharField(required=True, max_length=256)    new_password = serializers.CharField(required=True, max_length=256)    def validate(self, attrs):        if attrs['password'] == attrs['new_password']:            raise serializers.ValidationError('新密码不能和旧密码相同')        return attrsclass FrogetPasswordForm(serializers.Serializer):    '''    密码找回    '''    email = serializers.EmailField(required=True, max_length=50)